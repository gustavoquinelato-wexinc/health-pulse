<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse ETL - Dashboard v2</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-running {
            @apply bg-blue-500 text-white;
        }

        .status-pending {
            @apply bg-yellow-500 text-white;
        }

        .status-finished {
            @apply bg-green-500 text-white;
        }

        .status-paused {
            @apply bg-amber-600 text-white;
        }

        .status-not-started {
            @apply bg-gray-500 text-white;
        }

        .status-error {
            @apply bg-red-500 text-white;
        }



        /* Hamburger Menu Styles */
        .hamburger-menu {
            position: relative;
            z-index: 9999;
        }

        .menu-dropdown {
            position: fixed !important;
            top: 80px !important;
            right: 20px !important;
            background: #2d3748 !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 8px !important;
            min-width: 200px !important;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5) !important;
            z-index: 999999 !important;
            display: none !important;
        }

        .menu-dropdown.show {
            display: block !important;
        }

        .menu-item {
            display: block;
            padding: 12px 16px;
            color: white;
            text-decoration: none;
            transition: background-color 0.2s;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 500;
        }

        .menu-item:hover {
            background: #4299e1;
            color: white;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item i {
            width: 20px;
            margin-right: 8px;
        }



        /* Fix for select dropdown z-index issues */
        select {
            position: relative !important;
            z-index: 9999 !important;
        }

        /* Fix dropdown option colors */
        select option {
            background-color: #333 !important;
            color: white !important;
            padding: 8px !important;
        }

        select option:hover {
            background-color: #555 !important;
            color: white !important;
        }

        /* Specific styling for refresh interval dropdown */
        #refreshInterval option {
            background-color: #2d3748 !important;
            color: white !important;
            border: none !important;
        }

        #refreshInterval option:checked {
            background-color: #4299e1 !important;
            color: white !important;
        }

        /* Ensure the parent container doesn't clip the dropdown */
        .glass-effect {
            overflow: visible !important;
        }

        /* WebSocket Progress Bar Styles */
        .ws-progress-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .ws-progress-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
        }

        .ws-progress-bar.completed {
            background: linear-gradient(90deg, #10b981, #059669);
        }

        .ws-progress-bar.error {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }

        .ws-progress-text {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            margin-top: 4px;
        }

        /* Exception Log Styles */
        .exception-log {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
        }

        .exception-item {
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 11px;
            border-left: 3px solid;
        }

        .exception-item.error {
            background: rgba(239, 68, 68, 0.2);
            border-left-color: #ef4444;
            color: #fecaca;
        }

        .exception-item.warning {
            background: rgba(245, 158, 11, 0.2);
            border-left-color: #f59e0b;
            color: #fde68a;
        }

        .exception-item.info {
            background: rgba(59, 130, 246, 0.2);
            border-left-color: #3b82f6;
            color: #bfdbfe;
        }
    </style>
</head>

<body class="gradient-bg min-h-screen">
    <!-- Hamburger Menu Dropdown (positioned at body level to avoid z-index issues) -->
    <div id="menuDropdown" class="menu-dropdown">
        <a href="/dashboard" class="menu-item">
            <i class="fas fa-tachometer-alt"></i>Dashboard
        </a>
        <a href="/status" class="menu-item">
            <i class="fas fa-info-circle"></i>Status Page
        </a>
        <a href="/docs" class="menu-item">
            <i class="fas fa-book"></i>API Documentation
        </a>
        <a href="/health" class="menu-item">
            <i class="fas fa-heartbeat"></i>Health Check
        </a>
        <a href="/api/v1/admin" class="menu-item">
            <i class="fas fa-cog"></i>Admin Panel
        </a>
        <div class="menu-item"
            style="border-top: 1px solid rgba(255, 255, 255, 0.2); margin-top: 4px; padding-top: 12px;">
            <button onclick="logout()" class="w-full text-left">
                <i class="fas fa-sign-out-alt"></i>Logout
            </button>
        </div>
    </div>

    <!-- Header -->
    <header class="glass-effect border-b border-white border-opacity-20">
        <div class="container mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center">
                    <div
                        class="inline-flex items-center justify-center w-10 h-10 bg-white bg-opacity-20 rounded-full mr-4">
                        <i class="fas fa-database text-white"></i>
                    </div>
                    <div>
                        <h1 class="text-2xl font-bold text-white">Pulse ETL Dashboard</h1>
                        <p class="text-white text-opacity-70 text-sm">Data Pipeline Management</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <div class="text-white text-opacity-80 text-sm">
                        <i class="fas fa-user mr-2"></i>gustavo.quinelato@wexinc.com
                    </div>

                    <!-- Hamburger Menu Button -->
                    <div class="hamburger-menu">
                        <button onclick="toggleMenu()"
                            class="bg-white bg-opacity-20 hover:bg-opacity-30 text-white px-3 py-2 rounded-lg transition duration-300">
                            <i class="fas fa-bars"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-8">
        <!-- Auto-refresh controls -->
        <div class="glass-effect rounded-lg p-4 mb-6">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <h2 class="text-xl font-semibold text-white">
                        <i class="fas fa-sync-alt mr-2"></i>Job Status Monitor
                    </h2>
                    <div class="flex items-center space-x-2">
                        <label class="text-white text-sm">Auto-refresh:</label>
                        <select id="refreshInterval" class="bg-white bg-opacity-20 text-white rounded px-3 py-1 text-sm"
                            style="position: relative; z-index: 9999;">
                            <option value="0">Off</option>
                            <option value="5000">5s</option>
                            <option value="10000">10s</option>
                            <option value="30000" selected>30s</option>
                        </select>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <span id="lastUpdate" class="text-white text-opacity-70 text-sm"></span>
                    <button onclick="refreshData()"
                        class="bg-white bg-opacity-20 hover:bg-opacity-30 text-white px-4 py-2 rounded-lg transition duration-300">
                        <i class="fas fa-refresh mr-2"></i>Refresh Now
                    </button>
                </div>
            </div>
        </div>

        <!-- Orchestrator Controls -->
        <div class="glass-effect rounded-lg p-4 mb-6">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <h3 class="text-lg font-semibold text-white">
                        <i class="fas fa-cogs mr-2"></i>Orchestrator Controls
                    </h3>
                    <div id="orchestratorStatus" class="flex items-center space-x-4">
                        <div class="flex items-center space-x-2">
                            <span class="text-white text-opacity-70 text-sm">Status:</span>
                            <span id="orchestratorStatusBadge" class="px-2 py-1 rounded text-xs font-medium">
                                Loading...
                            </span>
                        </div>
                        <div id="orchestratorCountdown" class="flex items-center space-x-2">
                            <span class="text-white text-opacity-70 text-sm">Next run in:</span>
                            <span id="countdownTimer"
                                class="px-2 py-1 bg-blue-600 text-white rounded text-xs font-medium">
                                --:--:--
                            </span>
                        </div>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <button onclick="forceStartOrchestrator()" id="forceStartOrchestratorBtn"
                        class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm font-medium">
                        <i class="fas fa-play mr-1"></i>Force Start
                    </button>
                    <button onclick="pauseOrchestrator()" id="pauseOrchestratorBtn"
                        class="bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-1 rounded text-sm font-medium">
                        <i class="fas fa-pause mr-1"></i>Pause
                    </button>
                    <button onclick="resumeOrchestrator()" id="resumeOrchestratorBtn"
                        class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm font-medium hidden">
                        <i class="fas fa-play mr-1"></i>Resume
                    </button>
                    <button onclick="showOrchestratorSettings()"
                        class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm font-medium">
                        <i class="fas fa-cog mr-1"></i>Settings
                    </button>
                </div>
            </div>
        </div>

        <!-- Orchestrator Settings Modal -->
        <div id="orchestratorSettingsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
            <div class="flex items-center justify-center min-h-screen p-4">
                <div class="bg-white rounded-lg shadow-xl max-w-md w-full">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900">
                            <i class="fas fa-cog mr-2"></i>Orchestrator Settings
                        </h3>
                    </div>
                    <div class="px-6 py-4">
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">
                                    Run Interval
                                </label>
                                <select id="orchestratorInterval"
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="60" selected>Every 1 hour</option>
                                    <option value="120">Every 2 hours</option>
                                    <option value="240">Every 4 hours</option>
                                    <option value="480">Every 8 hours</option>
                                    <option value="720">Every 12 hours</option>
                                    <option value="1440">Every 24 hours</option>
                                </select>
                            </div>
                            <div>
                                <label class="flex items-center">
                                    <input type="checkbox" id="orchestratorEnabled" checked
                                        class="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                                    <span class="text-sm font-medium text-gray-700">Enable Orchestrator</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div class="px-6 py-4 border-t border-gray-200 flex justify-end space-x-3">
                        <button onclick="hideOrchestratorSettings()"
                            class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md">
                            Cancel
                        </button>
                        <button onclick="saveOrchestratorSettings()"
                            class="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md">
                            Save Changes
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Job Cards Container -->
        <div id="jobsContainer" class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <!-- Job cards will be dynamically inserted here -->
        </div>


    </main>

    <script>
        let refreshTimer = null;

        // WebSocket connections for real-time progress
        let websockets = {
            jira_sync: null,
            github_sync: null,
            orchestrator: null
        };

        // Progress and exception data
        let jobProgress = {
            jira_sync: { percentage: 0, step: '', exceptions: [] },
            github_sync: { percentage: 0, step: '', exceptions: [] },
            orchestrator: { percentage: 0, step: '', exceptions: [] }
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function () {
            checkAuth();
            refreshData();
            setupAutoRefresh();
            refreshOrchestratorStatus();
            initializeWebSockets();
        });

        function checkAuth() {
            const token = localStorage.getItem('pulse_token');
            if (!token) {
                window.location.href = '/login';
                return;
            }
        }

        // WebSocket Management
        function initializeWebSockets() {
            const jobs = ['jira_sync', 'github_sync'];

            jobs.forEach(jobName => {
                connectWebSocket(jobName);
            });
        }

        function connectWebSocket(jobName) {
            if (websockets[jobName]) {
                websockets[jobName].close();
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/progress/${jobName}`;

            try {
                const ws = new WebSocket(wsUrl);

                ws.onopen = function () {
                    console.log(`WebSocket connected for ${jobName}`);
                    websockets[jobName] = ws;
                };

                ws.onmessage = function (event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(jobName, data);
                    } catch (e) {
                        console.error(`Error parsing WebSocket message for ${jobName}:`, e);
                    }
                };

                ws.onclose = function () {
                    console.log(`WebSocket disconnected for ${jobName}`);
                    websockets[jobName] = null;

                    // Reconnect after 5 seconds
                    setTimeout(() => {
                        if (!websockets[jobName]) {
                            connectWebSocket(jobName);
                        }
                    }, 5000);
                };

                ws.onerror = function (error) {
                    console.error(`WebSocket error for ${jobName}:`, error);
                };

            } catch (e) {
                console.error(`Failed to create WebSocket for ${jobName}:`, e);
            }
        }

        function handleWebSocketMessage(jobName, data) {
            switch (data.type) {
                case 'progress':
                    updateJobProgress(jobName, data.percentage, data.step);
                    break;
                case 'exception':
                    addJobException(jobName, data.level, data.message, data.timestamp);
                    break;
                case 'status':
                    updateJobStatus(jobName, data.status);
                    break;
                case 'completion':
                    handleJobCompletion(jobName, data.success, data.summary);
                    break;
                default:
                    console.log(`Unknown WebSocket message type: ${data.type}`);
            }
        }

        function updateJobProgress(jobName, percentage, step) {
            jobProgress[jobName].percentage = percentage;
            jobProgress[jobName].step = step;

            // Update progress bar in job card
            const jobCard = document.querySelector(`[data-job="${jobName}"]`);
            if (jobCard) {
                updateJobCardProgress(jobCard, percentage, step);
            }
        }

        function addJobException(jobName, level, message, timestamp) {
            const exception = {
                level: level,
                message: message,
                timestamp: timestamp
            };

            jobProgress[jobName].exceptions.unshift(exception);

            // Keep only last 10 exceptions
            if (jobProgress[jobName].exceptions.length > 10) {
                jobProgress[jobName].exceptions = jobProgress[jobName].exceptions.slice(0, 10);
            }

            // Update exception log in job card
            const jobCard = document.querySelector(`[data-job="${jobName}"]`);
            if (jobCard) {
                updateJobCardExceptions(jobCard, jobProgress[jobName].exceptions);
            }
        }

        function updateJobStatus(jobName, status) {
            // Update job status in the UI
            const jobCard = document.querySelector(`[data-job="${jobName}"]`);
            if (jobCard) {
                updateJobCardStatus(jobCard, status);
            }
        }

        function handleJobCompletion(jobName, success, summary) {
            console.log(`Job ${jobName} completed:`, { success, summary });

            // Clear progress and show completion
            if (success) {
                updateJobProgress(jobName, 100, 'Completed successfully');
            } else {
                addJobException(jobName, 'ERROR', summary.error || 'Job failed', new Date().toISOString());
            }

            // Refresh job status after completion
            setTimeout(() => {
                refreshData();
            }, 2000);
        }

        function createWebSocketProgress(jobName) {
            const progress = jobProgress[jobName];
            if (!progress || progress.percentage === 0) {
                return '';
            }

            return `
                <div class="mt-4">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-xs font-medium text-white">Real-time Progress</span>
                        <span class="text-xs text-white">${Math.round(progress.percentage)}%</span>
                    </div>
                    <div class="ws-progress-container">
                        <div class="ws-progress-bar" style="width: ${progress.percentage}%"></div>
                    </div>
                    <div class="ws-progress-text">${progress.step}</div>
                </div>
            `;
        }

        function createExceptionLog(jobName) {
            const exceptions = jobProgress[jobName].exceptions;
            if (!exceptions || exceptions.length === 0) {
                return '';
            }

            const exceptionsHtml = exceptions.map(exception => `
                <div class="exception-item ${exception.level.toLowerCase()}">
                    <div class="flex justify-between items-start">
                        <span class="font-medium">${exception.level}:</span>
                        <span class="text-xs opacity-75">${new Date(exception.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="mt-1">${exception.message}</div>
                </div>
            `).join('');

            return `
                <div class="mt-4">
                    <div class="text-xs font-medium text-white mb-2">Issues & Warnings</div>
                    <div class="exception-log">
                        ${exceptionsHtml}
                    </div>
                </div>
            `;
        }

        function updateJobCardProgress(jobCard, percentage, step) {
            // Update or create progress section
            let progressSection = jobCard.querySelector('.ws-progress-container');
            if (!progressSection) {
                // Create progress section if it doesn't exist
                const detailsSection = jobCard.querySelector('.space-y-3');
                if (detailsSection) {
                    const progressHtml = createWebSocketProgress(jobCard.getAttribute('data-job'));
                    detailsSection.insertAdjacentHTML('afterend', progressHtml);
                    progressSection = jobCard.querySelector('.ws-progress-container');
                }
            }

            if (progressSection) {
                const progressBar = progressSection.querySelector('.ws-progress-bar');
                const progressText = jobCard.querySelector('.ws-progress-text');
                const progressPercentage = jobCard.querySelector('.ws-progress-container').parentElement.querySelector('.text-xs:last-child');

                if (progressBar) progressBar.style.width = `${percentage}%`;
                if (progressText) progressText.textContent = step;
                if (progressPercentage) progressPercentage.textContent = `${Math.round(percentage)}%`;
            }
        }

        function updateJobCardExceptions(jobCard, exceptions) {
            // Update or create exception log section
            let exceptionSection = jobCard.querySelector('.exception-log');
            if (!exceptionSection && exceptions.length > 0) {
                // Create exception section if it doesn't exist
                const progressSection = jobCard.querySelector('.ws-progress-container');
                const insertPoint = progressSection ? progressSection.parentElement : jobCard.querySelector('.space-y-3');
                if (insertPoint) {
                    const exceptionHtml = createExceptionLog(jobCard.getAttribute('data-job'));
                    insertPoint.insertAdjacentHTML('afterend', exceptionHtml);
                    exceptionSection = jobCard.querySelector('.exception-log');
                }
            }

            if (exceptionSection && exceptions.length > 0) {
                const exceptionsHtml = exceptions.map(exception => `
                    <div class="exception-item ${exception.level.toLowerCase()}">
                        <div class="flex justify-between items-start">
                            <span class="font-medium">${exception.level}:</span>
                            <span class="text-xs opacity-75">${new Date(exception.timestamp).toLocaleTimeString()}</span>
                        </div>
                        <div class="mt-1">${exception.message}</div>
                    </div>
                `).join('');
                exceptionSection.innerHTML = exceptionsHtml;
            }
        }

        function updateJobCardStatus(jobCard, status) {
            const statusSpan = jobCard.querySelector('.px-3.py-1.rounded-full');
            if (statusSpan) {
                const statusClass = getStatusClass(status);
                const statusIcon = getStatusIcon(status);
                statusSpan.className = `px-3 py-1 rounded-full text-sm font-medium ${statusClass}`;
                statusSpan.innerHTML = `<i class="fas fa-${statusIcon} mr-1"></i>${status}`;
            }
        }

        function logout() {
            localStorage.removeItem('pulse_token');
            window.location.href = '/login';
        }

        async function refreshData() {
            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch('/api/v1/jobs/status', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.status === 401) {
                    logout();
                    return;
                }

                const data = await response.json();
                updateJobCards(data.jobs || data);
                updateLastRefreshTime();



                // Note: Orchestrator status refreshed separately via countdown timer
            } catch (error) {
                console.error('Error fetching job status:', error);
            }
        }

        function updateJobCards(jobsData) {
            const container = document.getElementById('jobsContainer');
            container.innerHTML = '';

            Object.entries(jobsData).forEach(([jobName, jobData]) => {
                const card = createJobCard(jobName, jobData, jobsData);
                container.appendChild(card);
            });

            // Update orchestrator button state based on job status
            updateOrchestratorButtonState(jobsData);
        }

        function updateOrchestratorButtonState(jobsData) {
            const orchestratorBtn = document.getElementById('forceStartOrchestratorBtn');
            if (!orchestratorBtn) return;

            // Check if any job is running
            const anyJobRunning = Object.values(jobsData).some(jobData => jobData.status === 'RUNNING');

            if (anyJobRunning) {
                orchestratorBtn.disabled = true;
                orchestratorBtn.className = 'bg-gray-500 cursor-not-allowed text-white px-3 py-1 rounded text-sm font-medium';
                orchestratorBtn.title = 'Cannot start orchestrator while jobs are running';
            } else {
                orchestratorBtn.disabled = false;
                orchestratorBtn.className = 'bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm font-medium';
                orchestratorBtn.title = '';
            }
        }

        function setupAutoRefresh() {
            const select = document.getElementById('refreshInterval');
            select.addEventListener('change', function () {
                if (refreshTimer) {
                    clearInterval(refreshTimer);
                    refreshTimer = null;
                }

                const interval = parseInt(this.value);
                if (interval > 0) {
                    refreshTimer = setInterval(refreshData, interval);
                }
            });

            // Start with default 30s refresh
            const defaultInterval = parseInt(select.value);
            if (defaultInterval > 0) {
                refreshTimer = setInterval(refreshData, defaultInterval);
            }
        }

        function updateLastRefreshTime() {
            const now = new Date();
            document.getElementById('lastUpdate').textContent =
                `Last updated: ${now.toLocaleTimeString()}`;
        }

        function createJobCard(jobName, jobData, allJobsData) {
            const card = document.createElement('div');
            card.className = 'glass-effect rounded-lg p-6';
            card.setAttribute('data-job', jobName); // Add data attribute for WebSocket updates

            const statusClass = getStatusClass(jobData.status);
            const statusIcon = getStatusIcon(jobData.status);

            card.innerHTML = `
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-xl font-semibold text-white capitalize">
                        <i class="fas fa-${jobName === 'jira_sync' ? 'ticket-alt' : 'code-branch'} mr-2"></i>
                        ${jobName.replace('_', ' ')}
                    </h3>
                    <span class="px-3 py-1 rounded-full text-sm font-medium ${statusClass}">
                        <i class="fas fa-${statusIcon} mr-1"></i>${jobData.status}
                    </span>
                </div>

                ${createJobDetails(jobName, jobData)}
                ${createWebSocketProgress(jobName)}
                ${createExceptionLog(jobName)}

                <div class="mt-4 flex flex-wrap gap-2">
                    ${createActionButtons(jobName, jobData, allJobsData)}
                </div>
            `;

            return card;
        }

        function createJobDetails(jobName, jobData) {
            let details = `
                <div class="space-y-3 text-white text-opacity-80 text-sm">
                    <div class="flex justify-between">
                        <span>Last Run:</span>
                        <span>${jobData.last_run_started_at ? new Date(jobData.last_run_started_at).toLocaleString() : 'Never'}</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Last Success:</span>
                        <span>${jobData.last_success_at ? new Date(jobData.last_success_at).toLocaleString() : 'Never'}</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Retry Count:</span>
                        <span>${jobData.retry_count || 0}</span>
                    </div>
            `;



            details += `</div>`;

            // Add recovery details for PENDING jobs
            if (jobData.status === 'PENDING' && jobData.checkpoint_data) {
                details += createRecoveryDetails(jobData.checkpoint_data);
            }

            // Add error message if exists
            if (jobData.error_message) {
                details += `
                    <div class="mt-3 p-3 bg-red-500 bg-opacity-20 rounded-lg border border-red-500 border-opacity-50">
                        <div class="text-red-200 text-xs font-medium mb-1">Error Message:</div>
                        <div class="text-red-100 text-xs">${jobData.error_message}</div>
                    </div>
                `;
            }

            details += '</div>';
            return details;
        }

        function createRecoveryDetails(checkpointData) {
            if (!checkpointData) return '';

            let recoveryHtml = `
                <div class="mt-3 p-3 bg-yellow-500 bg-opacity-20 rounded-lg border border-yellow-500 border-opacity-50">
                    <div class="text-yellow-200 text-xs font-medium mb-2">
                        <i class="fas fa-redo mr-1"></i>Recovery Information:
                    </div>
            `;

            // Repository queue information
            if (checkpointData.repo_processing_queue) {
                // Handle both string and object formats
                let queue;
                if (typeof checkpointData.repo_processing_queue === 'string') {
                    queue = JSON.parse(checkpointData.repo_processing_queue);
                } else {
                    queue = checkpointData.repo_processing_queue;
                }

                const finished = queue.filter(r => r.finished).length;
                const total = queue.length;
                const remaining = total - finished;

                recoveryHtml += `
                    <div class="text-yellow-100 text-xs mb-1">
                        Repositories: ${finished}/${total} completed (${remaining} remaining)
                    </div>
                `;
            }

            // Cursor information
            const cursors = ['last_pr_cursor', 'current_pr_node_id', 'last_commit_cursor', 'last_review_cursor', 'last_comment_cursor'];
            cursors.forEach(cursor => {
                if (checkpointData[cursor]) {
                    recoveryHtml += `
                        <div class="text-yellow-100 text-xs mb-1">
                            ${cursor.replace(/_/g, ' ')}: ${checkpointData[cursor].substring(0, 20)}...
                        </div>
                    `;
                }
            });

            recoveryHtml += '</div>';
            return recoveryHtml;
        }

        function createActionButtons(jobName, jobData, allJobsData) {
            const canStart = ['PENDING', 'FINISHED', 'NOT_STARTED'].includes(jobData.status);
            const canStop = jobData.status === 'RUNNING';
            const canPause = ['PENDING', 'FINISHED'].includes(jobData.status);
            const canUnpause = jobData.status === 'PAUSED';

            // Check if any other job is running to disable Force Start
            const otherJobRunning = Object.entries(allJobsData).some(([name, data]) =>
                name !== jobName && data.status === 'RUNNING'
            );

            // Disable Force Start if other job is running
            const canStartSafe = canStart && !otherJobRunning;

            // Disable Pause if this job is running
            const canPauseSafe = canPause && jobData.status !== 'RUNNING';

            return `
                <button onclick="forceStart('${jobName}')"
                        ${!canStartSafe ? 'disabled' : ''}
                        class="px-3 py-1 rounded text-sm ${canStartSafe ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-500 cursor-not-allowed'} text-white transition duration-300"
                        title="${!canStartSafe && otherJobRunning ? 'Cannot start while another job is running' : ''}">
                    <i class="fas fa-play mr-1"></i>Force Start
                </button>
                <button onclick="forceStop('${jobName}')"
                        ${!canStop ? 'disabled' : ''}
                        class="px-3 py-1 rounded text-sm ${canStop ? 'bg-red-500 hover:bg-red-600' : 'bg-gray-500 cursor-not-allowed'} text-white transition duration-300">
                    <i class="fas fa-stop mr-1"></i>Force Stop
                </button>
                <button onclick="${canUnpause ? 'unpauseJob' : 'pauseJob'}('${jobName}')"
                        ${!(canPauseSafe || canUnpause) ? 'disabled' : ''}
                        class="px-3 py-1 rounded text-sm ${(canPauseSafe || canUnpause) ? (canUnpause ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-amber-500 hover:bg-amber-600') : 'bg-gray-500 cursor-not-allowed'} text-white transition duration-300"
                        title="${!canPauseSafe && jobData.status === 'RUNNING' ? 'Cannot pause while job is running' : ''}">
                    <i class="fas fa-${canUnpause ? 'play' : 'pause'} mr-1"></i>${canUnpause ? 'Unpause' : 'Pause'}
                </button>
                <button onclick="showJobDetails('${jobName}')"
                        class="px-3 py-1 rounded text-sm bg-purple-500 hover:bg-purple-600 text-white transition duration-300">
                    <i class="fas fa-info-circle mr-1"></i>Details
                </button>
            `;
        }

        function getStatusClass(status) {
            switch (status) {
                case 'RUNNING': return 'status-running';
                case 'PENDING': return 'status-pending';
                case 'FINISHED': return 'status-finished';
                case 'PAUSED': return 'status-paused';
                case 'NOT_STARTED': return 'status-not-started';
                default: return 'status-error';
            }
        }

        function getStatusIcon(status) {
            switch (status) {
                case 'RUNNING': return 'spinner fa-spin';
                case 'PENDING': return 'clock';
                case 'FINISHED': return 'check-circle';
                case 'PAUSED': return 'pause-circle';
                case 'NOT_STARTED': return 'circle';
                default: return 'exclamation-triangle';
            }
        }



        // Job action functions
        async function forceStart(jobName) {
            if (!confirm(`Are you sure you want to force start ${jobName}?`)) return;

            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch(`/api/v1/jobs/${jobName}/start`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (response.ok) {
                    console.log(`${jobName} started successfully`);
                    refreshData();
                } else {
                    console.error(`Failed to start ${jobName}: ${result.detail}`);
                }
            } catch (error) {
                console.error(`Error starting ${jobName}: ${error.message}`);
            }
        }

        async function forceStop(jobName) {
            if (!confirm(`Are you sure you want to force stop ${jobName}?`)) return;

            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch(`/api/v1/jobs/${jobName}/stop`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (response.ok) {
                    console.log(`${jobName} stopped successfully`);
                    refreshData();
                } else {
                    console.error(`Failed to stop ${jobName}: ${result.detail}`);
                }
            } catch (error) {
                console.error(`Error stopping ${jobName}: ${error.message}`);
            }
        }



        function showJobDetails(jobName) {
            // Future enhancement: Implement job details modal with execution history, performance metrics, and detailed logs
            console.log(`Showing details for ${jobName} (feature coming soon)`);
        }

        async function pauseJob(jobName) {
            if (!confirm(`Are you sure you want to pause ${jobName}?`)) return;

            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch(`/api/v1/jobs/${jobName}/pause`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (response.ok) {
                    console.log(`${jobName} paused successfully`);
                    await refreshData(); // Refresh to show updated status
                } else {
                    console.error(`Failed to pause ${jobName}: ${result.detail || result.message}`);
                }
            } catch (error) {
                console.error(`Error pausing ${jobName}: ${error.message}`);
            }
        }

        async function unpauseJob(jobName) {
            if (!confirm(`Are you sure you want to unpause ${jobName}?`)) return;

            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch(`/api/v1/jobs/${jobName}/unpause`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (response.ok) {
                    console.log(`${jobName} unpaused successfully - new status: ${result.status}`);
                    await refreshData(); // Refresh to show updated status
                } else {
                    console.error(`Failed to unpause ${jobName}: ${result.detail || result.message}`);
                }
            } catch (error) {
                console.error(`Error unpausing ${jobName}: ${error.message}`);
            }
        }

        // Orchestrator Control Functions
        async function forceStartOrchestrator() {
            const button = event.target.closest('button');

            // Check if button is disabled
            if (button.disabled) {
                console.warn('Cannot start orchestrator while jobs are running');
                return;
            }

            const originalText = button.innerHTML;

            try {
                // Show loading state
                button.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Starting...';
                button.disabled = true;

                console.log('Force starting orchestrator... (this may take a few seconds)');

                const token = localStorage.getItem('pulse_token');
                const response = await fetch('/api/v1/orchestrator/start', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (response.ok) {
                    console.log('Orchestrator started successfully');
                    // Refresh status after a short delay to allow scheduler to update
                    setTimeout(refreshOrchestratorStatus, 1000);
                } else {
                    console.error(`Failed to start orchestrator: ${result.detail}`);
                }
            } catch (error) {
                console.error(`Error starting orchestrator: ${error.message}`);
            } finally {
                // Restore button state
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }

        async function pauseOrchestrator() {
            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch('/api/v1/orchestrator/pause', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (response.ok) {
                    console.warn('Orchestrator paused');
                    setTimeout(refreshOrchestratorStatus, 500);
                } else {
                    console.error(`Failed to pause orchestrator: ${result.detail}`);
                }
            } catch (error) {
                console.error(`Error pausing orchestrator: ${error.message}`);
            }
        }

        async function resumeOrchestrator() {
            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch('/api/v1/orchestrator/resume', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (response.ok) {
                    console.log('Orchestrator resumed');
                    setTimeout(refreshOrchestratorStatus, 500);
                } else {
                    console.error(`Failed to resume orchestrator: ${result.detail}`);
                }
            } catch (error) {
                console.error(`Error resuming orchestrator: ${error.message}`);
            }
        }

        async function refreshOrchestratorStatus() {
            try {
                const token = localStorage.getItem('pulse_token');
                const response = await fetch('/api/v1/orchestrator/status', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    const status = await response.json();
                    updateOrchestratorUI(status);
                }
            } catch (error) {
                console.error('Error fetching orchestrator status:', error);
            }
        }

        let countdownInterval = null;

        function updateOrchestratorUI(status) {
            const statusBadge = document.getElementById('orchestratorStatusBadge');
            const pauseBtn = document.getElementById('pauseOrchestratorBtn');
            const resumeBtn = document.getElementById('resumeOrchestratorBtn');

            // Update status badge
            statusBadge.textContent = status.status;
            statusBadge.className = 'px-2 py-1 rounded text-xs font-medium ';

            if (status.status === 'running') {
                statusBadge.className += 'bg-green-600 text-white';
                pauseBtn.classList.remove('hidden');
                resumeBtn.classList.add('hidden');

                // Start countdown timer
                startCountdownTimer(status.next_run);
            } else if (status.status === 'paused') {
                statusBadge.className += 'bg-yellow-600 text-white';
                pauseBtn.classList.add('hidden');
                resumeBtn.classList.remove('hidden');

                // Stop countdown timer when paused
                stopCountdownTimer();
            } else {
                statusBadge.className += 'bg-gray-600 text-white';
                pauseBtn.classList.add('hidden');
                resumeBtn.classList.add('hidden');

                // Stop countdown timer when not running
                stopCountdownTimer();
            }
        }

        function startCountdownTimer(nextRunTime) {
            // Clear any existing timer
            stopCountdownTimer();

            if (!nextRunTime) {
                document.getElementById('countdownTimer').textContent = '--:--:--';
                return;
            }

            const nextRun = new Date(nextRunTime);

            countdownInterval = setInterval(() => {
                const now = new Date();
                const timeDiff = nextRun - now;

                if (timeDiff <= 0) {
                    document.getElementById('countdownTimer').textContent = '00:00:00';
                    // Refresh orchestrator status when countdown reaches zero
                    setTimeout(refreshOrchestratorStatus, 1000);
                    return;
                }

                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('countdownTimer').textContent = timeString;
            }, 1000);
        }

        function stopCountdownTimer() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            document.getElementById('countdownTimer').textContent = '--:--:--';
        }

        // Orchestrator Settings Functions
        async function showOrchestratorSettings() {
            try {
                // Load current settings
                const response = await fetch('/api/v1/settings', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('pulse_token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    const settings = data.settings;

                    // Update modal with current values
                    const intervalSelect = document.getElementById('orchestratorInterval');
                    const enabledCheckbox = document.getElementById('orchestratorEnabled');

                    if (settings.orchestrator_interval_minutes) {
                        intervalSelect.value = settings.orchestrator_interval_minutes.value;
                    }

                    if (settings.orchestrator_enabled) {
                        enabledCheckbox.checked = settings.orchestrator_enabled.value;
                    }
                }

                // Show modal
                document.getElementById('orchestratorSettingsModal').classList.remove('hidden');

            } catch (error) {
                console.error('Failed to load orchestrator settings:', error);
            }
        }

        function hideOrchestratorSettings() {
            document.getElementById('orchestratorSettingsModal').classList.add('hidden');
        }

        async function saveOrchestratorSettings() {
            try {
                const intervalSelect = document.getElementById('orchestratorInterval');
                const enabledCheckbox = document.getElementById('orchestratorEnabled');

                const intervalMinutes = parseInt(intervalSelect.value);
                const enabled = enabledCheckbox.checked;

                const response = await fetch('/api/v1/orchestrator/schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('pulse_token')}`
                    },
                    body: JSON.stringify({
                        interval_minutes: intervalMinutes,
                        enabled: enabled
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    console.log(`Orchestrator schedule updated: ${intervalMinutes} minutes, enabled: ${enabled}`);
                    hideOrchestratorSettings();

                    // Refresh orchestrator status to show new schedule
                    setTimeout(refreshOrchestratorStatus, 1000);
                } else {
                    console.error(`Failed to update orchestrator schedule: ${result.detail}`);
                }

            } catch (error) {
                console.error('Failed to save orchestrator settings:', error);
            }
        }

        // Hamburger Menu Functions
        function toggleMenu() {
            const dropdown = document.getElementById('menuDropdown');
            console.log('Toggle menu clicked, dropdown:', dropdown);
            dropdown.classList.toggle('show');
            console.log('Menu classes after toggle:', dropdown.className);
        }

        // Close menu when clicking outside
        document.addEventListener('click', function (event) {
            const menu = document.querySelector('.hamburger-menu');
            const dropdown = document.getElementById('menuDropdown');

            if (!menu.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });
    </script>
</body>

</html>